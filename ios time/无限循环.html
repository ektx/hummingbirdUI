<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Demo</title>
	<style>
	.mod {
		width: 300px;
		height: 300px;
		margin: 200px auto;
		border: 2px solid #000;
		/*overflow: hidden*/
	
	}
	.box{
		position: relative;
		height: 100%;
		/*transition: transform 400ms ease;*/
	}
	.child {
		position: absolute;
		top: 0;
		width: 420px;
		height: 100%;
		opacity: .8;
		z-index: 1
	}
	.red {
		background: red
	}
	.yellow {
		background: yellow;
	}

	.current {
		top: 0;
	}
	</style>
</head>
<body>
	<div class="mod">
		<div class="box">
			<div class="child red current"></div>
			<div class="child yellow ready" style="transform: translatex(420px)"></div>
		</div>
	</div>


	<ul style="position: fixed; top: 0">
		<li id="newBoxPosX-s"></li>
		<li ><span id="zf"></span></li>
	</ul>
	<label>
		<input id="hide" type="checkbox">hide
	</label>
	<script src="jquery.js"></script>
	<script>

	document.getElementById('hide').addEventListener('click', function() {
		var isChecked = document.getElementById('hide').checked;

		if (isChecked) {
			document.getElementsByClassName('mod')[0].style.overflow = 'hidden'
		} else {
			document.getElementsByClassName('mod')[0].style.overflow = 'initial'
			
		}
	})



	var currentY, boxPositionY;
	var eventTime = {};
	var eventPosition = {};

	$('.mod')
	.mousedown(function(e) {
		eventPosition.startX = e.originalEvent.layerX;
		eventTime.start = e.timeStamp;

		// 获取当前的位置信息
		boxPositionX = getTransForm('.box')

		console.log('原始位置：'+eventPosition.startX )
	
	})
	.mousemove(function(e) {
		if (e.buttons === 1) {
			var move = e.originalEvent.layerX - eventPosition.startX
			var newBoxPosX = boxPositionX + move;

			var start_X = newBoxPosX

			$('#newBoxPosX-s').text(newBoxPosX)

			moveChild(newBoxPosX)

			// 设置顶层移动距离
			$('.box').css({
				transform: 'translate3d('+newBoxPosX+'px, 0,0)'
			})

		}
	})
	.mouseup(function(e) {
		eventTime.end = e.timeStamp;
		eventPosition.endX = e.originalEvent.layerX;
		console.log(eventTime, eventPosition)

		var useT = eventTime.end - eventTime.start;
		var useL = eventPosition.endX - eventPosition.startX;

		var useS = useL / useT;
		var goTime = 400;

		// 如果移动时间大于这个动画时间
		// 我们认为你是不用加速运动的
		if (useT > goTime) return

		var nowPosition = getTransForm($('.box'))
		var willGoTo = useS * goTime;
		var willGo   = willGoTo + nowPosition;
		console.log(willGoTo, willGo)

		$('.box').css({
			transform: 'translate3d('+willGo+'px,0,0)',
			transition: 'transform '+goTime+'ms ease'
		})

		setTimeout(function() {
			$('.box').css({
				transition: 'transform 0ms ease'
			})

		}, goTime)


		// @delay: 动画帧数
		// @duration: 动画运行时间
		// @delta: 对进度操作
		// @step: 每一帧操作
		animate({
			delay: 10,
			duration: goTime,
			delta: makeEaseOut(quad),
			step: function(delta) {
				var newVal = willGoTo * delta
				console.log(newVal)
				moveChild(newVal+ nowPosition)

			}
		})

		console.log(useT, 'ms')
		console.log(useL, 'px')
		console.log(useS * 200, 'px/ms')
	});
	
	
	// 获取元素当前 translateX 值
	function getTransForm (element) {
		var getTransForm = $(element).css('transform');
		getTransForm = getTransForm == 'none' ? 'matrix(1, 0, 0, 1, 0, 0)' : getTransForm; 
		
		return Number(getTransForm.split(',')[4].replace(')',''));		
	}

	function quad(progress) {
		return Math.pow(progress, 5)
	}

	function makeEaseOut(delta) {
		return function(progress) {
			return 1 - delta(1 - progress)
		}
	}

	function animate(opts) {

		var start = new Date
		
		var id = setInterval(function() {
			var timePassed = new Date - start;
			// 进程，已经完成了多少，从0到1
			var progress = timePassed / opts.duration

			if (progress > 1) progress = 1;

			var delta = opts.delta(progress)
			opts.step(delta)

			if (progress == 1) clearInterval(id)
		}, opts.delay || 10)
	}

	// 移动主框架
	// @newPosition 新地址
	function moveChild (newPosition) {

		$('.child').each(function(index) {
			var iPositionX = getTransForm($(this));
			var _getIPX = 0;

			// 计算
			if (iPositionX%(420*2) == 0) {
				_getIPX = 0 - Math.ceil(newPosition/(420*2))*420*2;
			} else {
				_getIPX = 420 - Math.ceil(newPosition/(420*2))*420*2;
			}

			// 如果和计算的值不相等，自动变成相等
			if (_getIPX !== iPositionX) {

				iPositionX = _getIPX;

				$(this).css({
					transform: 'translate3d('+iPositionX+'px,0,0)'
				})
			}

			// 相对开始位置
			var relativeX = iPositionX + newPosition;
			// 相对结束位置
			var relativeE = relativeX + 420;

			// console.log(index, '开始点:', relativeX)
			// console.log(index, '结束点:', relativeE)


			// 我们来判断开始点的位置
			// 如果是在 0 到 300 那么,一定是在显示区中
			// 此时只有开始的部分能看到
			if (relativeX > 0 && relativeX < 300) {
				// console.log('在之间,部分显示')
			} 
			// 如果不在 0 到 300 之间
			// 那么可能是在 0 前,那就是移动到了左边
			// 要么在 300 之后,移动到了右边
			else {

				// 如果是在 0 前面
				if (relativeX < 0 ) {

					// 那么我们看下结束点在那
					// 如果结束点 > 0,那就是在显示区中
					if (relativeE > 0) {
						
						// ::这里主要是状态说明,并没有实际作用
						// 如果还大于 300 那就是全部显示中,独占显示区
						if (relativeE > 300) {
							// console.log('全部显示中')
						} 
						// 反之则是只有尾部部分在了,快要结束或只是开始
						else {
							// console.log('尾部显示中')
						}
					}

					// 如果小于 0,那么说明它整个都已经移过了显示区
					else {

						// 我们设置一个缓冲
						// 不用让它一过显示区就移动位置
						// 万一用户马上回来又要移动位置,这样操作太频繁了
						var buffer = 0 - (420 - 300)/2;

						// 当结束点也小于缓冲区了,开始移动到新位置上
						if (relativeE < buffer) {
							$(this).css({
								transform: 'translate3d('+(iPositionX+ 420 *2)+'px,0,0)'
							})

						}
						
					}


				} 

				// 如果当前位置在 300 之后
				// 那它就看不见
				else if (relativeX > 300 ) {

					var buffer = (420 - 300)/2 + 300;

					// 同时它还在可视位置后的缓冲之外
					// 那它直接移动新位置上
					if (relativeX > buffer) {

						$(this).css({
							transform: 'translate3d('+(iPositionX- 420 *2)+'px,0,0)'
						})
					}
				}
			}

		});



	}
	</script>
</body>
</html>